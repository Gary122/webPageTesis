{"ast":null,"code":"import React from 'react';\nimport { Animated, StyleSheet } from 'react-native';\nimport AnimatedText from '../../Typography/AnimatedText';\nconst InputLabel = props => {\n  const {\n    labeled,\n    wiggle,\n    error,\n    focused,\n    opacity,\n    labelLayoutWidth,\n    labelBackground,\n    label,\n    labelError,\n    onLayoutAnimatedText,\n    hasActiveOutline,\n    activeColor,\n    placeholderStyle,\n    baseLabelTranslateX,\n    baseLabelTranslateY,\n    font,\n    fontSize,\n    lineHeight,\n    fontWeight,\n    placeholderOpacity,\n    wiggleOffsetX,\n    labelScale,\n    topPosition,\n    paddingLeft,\n    paddingRight,\n    backgroundColor,\n    roundness,\n    placeholderColor,\n    errorColor,\n    labelTranslationXOffset,\n    maxFontSizeMultiplier,\n    testID\n  } = props;\n  const paddingOffset = paddingLeft && paddingRight ? {\n    paddingLeft,\n    paddingRight\n  } : {};\n  const labelTranslationX = {\n    transform: [{\n      // Offset label scale since RN doesn't support transform origin\n      translateX: labeled.interpolate({\n        inputRange: [0, 1],\n        outputRange: [baseLabelTranslateX, labelTranslationXOffset || 0]\n      })\n    }]\n  };\n  const labelStyle = {\n    ...font,\n    fontSize,\n    lineHeight,\n    fontWeight,\n    opacity: labeled.interpolate({\n      inputRange: [0, 1],\n      outputRange: [hasActiveOutline ? 1 : 0, 0]\n    }),\n    transform: [{\n      // Wiggle the label when there's an error\n      translateX: wiggle ? error.interpolate({\n        inputRange: [0, 0.5, 1],\n        outputRange: [0, wiggleOffsetX, 0]\n      }) : 0\n    }, {\n      // Move label to top\n      translateY: baseLabelTranslateY !== 0 ? labeled.interpolate({\n        inputRange: [0, 1],\n        outputRange: [baseLabelTranslateY, 0]\n      }) : 0\n    }, {\n      // Make label smaller\n      scale: labelScale !== 0 ? labeled.interpolate({\n        inputRange: [0, 1],\n        outputRange: [labelScale, 1]\n      }) : labeled\n    }]\n  };\n  const textColor = labelError && errorColor ? errorColor : placeholderColor;\n  return /*#__PURE__*/(\n    // Position colored placeholder and gray placeholder on top of each other and crossfade them\n    // This gives the effect of animating the color, but allows us to use native driver\n    React.createElement(Animated.View, {\n      pointerEvents: \"none\",\n      style: [StyleSheet.absoluteFill, styles.labelContainer, {\n        opacity\n      }, labelTranslationX]\n    }, labelBackground === null || labelBackground === void 0 ? void 0 : labelBackground({\n      labeled,\n      labelLayoutWidth,\n      labelStyle,\n      placeholderStyle,\n      baseLabelTranslateX,\n      topPosition,\n      label,\n      backgroundColor,\n      roundness,\n      maxFontSizeMultiplier: maxFontSizeMultiplier\n    }), /*#__PURE__*/React.createElement(AnimatedText, {\n      variant: \"bodySmall\",\n      onLayout: onLayoutAnimatedText,\n      style: [placeholderStyle, {\n        top: topPosition\n      }, labelStyle, paddingOffset || {}, {\n        color: activeColor\n      }],\n      numberOfLines: 1,\n      maxFontSizeMultiplier: maxFontSizeMultiplier,\n      testID: `${testID}-label-active`\n    }, label), /*#__PURE__*/React.createElement(AnimatedText, {\n      variant: focused ? 'bodyLarge' : 'bodySmall',\n      style: [placeholderStyle, {\n        top: topPosition\n      }, labelStyle, paddingOffset, {\n        color: textColor,\n        opacity: placeholderOpacity\n      }],\n      numberOfLines: 1,\n      maxFontSizeMultiplier: maxFontSizeMultiplier,\n      testID: `${testID}-label-inactive`\n    }, label))\n  );\n};\nconst styles = StyleSheet.create({\n  labelContainer: {\n    zIndex: 3\n  }\n});\nexport default /*#__PURE__*/React.memo(InputLabel);","map":{"version":3,"names":["React","Animated","StyleSheet","AnimatedText","InputLabel","props","labeled","wiggle","error","focused","opacity","labelLayoutWidth","labelBackground","label","labelError","onLayoutAnimatedText","hasActiveOutline","activeColor","placeholderStyle","baseLabelTranslateX","baseLabelTranslateY","font","fontSize","lineHeight","fontWeight","placeholderOpacity","wiggleOffsetX","labelScale","topPosition","paddingLeft","paddingRight","backgroundColor","roundness","placeholderColor","errorColor","labelTranslationXOffset","maxFontSizeMultiplier","testID","paddingOffset","labelTranslationX","transform","translateX","interpolate","inputRange","outputRange","labelStyle","translateY","scale","textColor","createElement","View","pointerEvents","style","absoluteFill","styles","labelContainer","variant","onLayout","top","color","numberOfLines","create","zIndex","memo"],"sources":["C:\\Users\\Cristobal\\Desktop\\proyectoTesis\\client\\node_modules\\react-native-paper\\src\\components\\TextInput\\Label\\InputLabel.tsx"],"sourcesContent":["import React from 'react';\nimport { Animated, StyleSheet } from 'react-native';\n\nimport AnimatedText from '../../Typography/AnimatedText';\nimport type { InputLabelProps } from '../types';\n\nconst InputLabel = (props: InputLabelProps) => {\n  const {\n    labeled,\n    wiggle,\n    error,\n    focused,\n    opacity,\n    labelLayoutWidth,\n    labelBackground,\n    label,\n    labelError,\n    onLayoutAnimatedText,\n    hasActiveOutline,\n    activeColor,\n    placeholderStyle,\n    baseLabelTranslateX,\n    baseLabelTranslateY,\n    font,\n    fontSize,\n    lineHeight,\n    fontWeight,\n    placeholderOpacity,\n    wiggleOffsetX,\n    labelScale,\n    topPosition,\n    paddingLeft,\n    paddingRight,\n    backgroundColor,\n    roundness,\n    placeholderColor,\n    errorColor,\n    labelTranslationXOffset,\n    maxFontSizeMultiplier,\n    testID,\n  } = props;\n\n  const paddingOffset =\n    paddingLeft && paddingRight ? { paddingLeft, paddingRight } : {};\n\n  const labelTranslationX = {\n    transform: [\n      {\n        // Offset label scale since RN doesn't support transform origin\n        translateX: labeled.interpolate({\n          inputRange: [0, 1],\n          outputRange: [baseLabelTranslateX, labelTranslationXOffset || 0],\n        }),\n      },\n    ],\n  };\n\n  const labelStyle = {\n    ...font,\n    fontSize,\n    lineHeight,\n    fontWeight,\n    opacity: labeled.interpolate({\n      inputRange: [0, 1],\n      outputRange: [hasActiveOutline ? 1 : 0, 0],\n    }),\n    transform: [\n      {\n        // Wiggle the label when there's an error\n        translateX: wiggle\n          ? error.interpolate({\n              inputRange: [0, 0.5, 1],\n              outputRange: [0, wiggleOffsetX, 0],\n            })\n          : 0,\n      },\n      {\n        // Move label to top\n        translateY:\n          baseLabelTranslateY !== 0\n            ? labeled.interpolate({\n                inputRange: [0, 1],\n                outputRange: [baseLabelTranslateY, 0],\n              })\n            : 0,\n      },\n      {\n        // Make label smaller\n        scale:\n          labelScale !== 0\n            ? labeled.interpolate({\n                inputRange: [0, 1],\n                outputRange: [labelScale, 1],\n              })\n            : labeled,\n      },\n    ],\n  };\n\n  const textColor = labelError && errorColor ? errorColor : placeholderColor;\n\n  return (\n    // Position colored placeholder and gray placeholder on top of each other and crossfade them\n    // This gives the effect of animating the color, but allows us to use native driver\n    <Animated.View\n      pointerEvents=\"none\"\n      style={[\n        StyleSheet.absoluteFill,\n        styles.labelContainer,\n        { opacity },\n        labelTranslationX,\n      ]}\n    >\n      {labelBackground?.({\n        labeled,\n        labelLayoutWidth,\n        labelStyle,\n        placeholderStyle,\n        baseLabelTranslateX,\n        topPosition,\n        label,\n        backgroundColor,\n        roundness,\n        maxFontSizeMultiplier: maxFontSizeMultiplier,\n      })}\n      <AnimatedText\n        variant=\"bodySmall\"\n        onLayout={onLayoutAnimatedText}\n        style={[\n          placeholderStyle,\n          {\n            top: topPosition,\n          },\n          labelStyle,\n          paddingOffset || {},\n          {\n            color: activeColor,\n          },\n        ]}\n        numberOfLines={1}\n        maxFontSizeMultiplier={maxFontSizeMultiplier}\n        testID={`${testID}-label-active`}\n      >\n        {label}\n      </AnimatedText>\n      <AnimatedText\n        variant={focused ? 'bodyLarge' : 'bodySmall'}\n        style={[\n          placeholderStyle,\n          {\n            top: topPosition,\n          },\n          labelStyle,\n          paddingOffset,\n          {\n            color: textColor,\n            opacity: placeholderOpacity,\n          },\n        ]}\n        numberOfLines={1}\n        maxFontSizeMultiplier={maxFontSizeMultiplier}\n        testID={`${testID}-label-inactive`}\n      >\n        {label}\n      </AnimatedText>\n    </Animated.View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  labelContainer: {\n    zIndex: 3,\n  },\n});\n\nexport default React.memo(InputLabel);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}